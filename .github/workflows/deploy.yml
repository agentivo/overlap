name: Deploy

on:
  workflow_dispatch:
    inputs:
      duration_hours:
        description: 'Duration in hours (max 5.5)'
        required: false
        default: '5'
      auto_restart:
        description: 'Auto-restart before timeout'
        required: false
        default: 'true'
        type: boolean

  repository_dispatch:
    types: [restart-deploy]

jobs:
  deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 350
    permissions:
      actions: write
      contents: write

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: npm install

      - name: Find previous workflow
        id: find_previous
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          PREVIOUS_RUN_ID=$(curl -s \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/workflows/deploy.yml/runs?status=in_progress" \
            | jq -r ".workflow_runs[] | select(.id < ${{ github.run_id }}) | .id" | head -1)

          if [ -n "$PREVIOUS_RUN_ID" ] && [ "$PREVIOUS_RUN_ID" != "null" ]; then
            echo "previous_run_id=$PREVIOUS_RUN_ID" >> $GITHUB_OUTPUT
            echo "Found previous run: $PREVIOUS_RUN_ID"
          else
            echo "previous_run_id=" >> $GITHUB_OUTPUT
            echo "No previous run found"
          fi

      - name: Download persisted data
        continue-on-error: true
        env:
          DATA_KEY: ${{ secrets.DATA_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Download current data (old workflow still running)
          RESPONSE=$(curl -s -H "Authorization: token $GH_TOKEN" \
            "https://api.github.com/repos/agentivo/overlap/contents/radata.enc?ref=data")

          CONTENT=$(echo "$RESPONSE" | jq -r '.content // empty' | tr -d '\n')

          if [ -n "$CONTENT" ]; then
            echo "$CONTENT" | base64 -d > radata.enc
            if openssl enc -aes-256-cbc -pbkdf2 -d -in radata.enc -out radata.tar.gz -pass pass:"$DATA_KEY" 2>/dev/null; then
              tar -xzf radata.tar.gz
              rm radata.tar.gz radata.enc
              echo "Restored data from data branch"
              ls -la radata
            else
              echo "WARNING: Failed to decrypt data (key may have changed)"
              rm -f radata.enc radata.tar.gz
            fi
          else
            echo "No previous data found, starting fresh"
          fi

      - name: Start server
        run: |
          node server.js &
          sleep 2
          curl -f http://localhost:3000/health || exit 1
          echo "Overlap server started successfully"

      - name: Setup Cloudflare Tunnel
        run: |
          curl -L https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -o cloudflared
          chmod +x cloudflared
          ./cloudflared tunnel --url http://localhost:3000 --no-autoupdate run --token "${{ secrets.TUNNEL_TOKEN }}" &
          sleep 5
          echo "Tunnel started"

      - name: Cancel previous workflow
        if: steps.find_previous.outputs.previous_run_id != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "New server ready - cancelling previous workflow..."
          curl -s -X POST \
            -H "Authorization: token $GH_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ steps.find_previous.outputs.previous_run_id }}/cancel"
          echo "Graceful handoff complete"

      - name: Monitor
        env:
          APP_ID: ${{ secrets.APP_ID }}
          APP_PRIVATE_KEY: ${{ secrets.APP_PRIVATE_KEY }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DATA_KEY: ${{ secrets.DATA_KEY }}
        run: |
          upload_data() {
            if [ ! -d "radata" ]; then
              echo "No radata directory to upload"
              return
            fi

            echo "Backing up data..."

            # Create encrypted tar archive
            tar -czf radata.tar.gz radata
            openssl enc -aes-256-cbc -pbkdf2 -in radata.tar.gz -out radata.enc -pass pass:"$DATA_KEY"
            rm radata.tar.gz

            # Upload as base64 via GitHub API
            CONTENT=$(base64 -w 0 radata.enc)

            # Check if file exists on data branch
            EXISTING_SHA=$(curl -s -H "Authorization: token $GH_TOKEN" \
              "https://api.github.com/repos/agentivo/overlap/contents/radata.enc?ref=data" | jq -r '.sha // empty')

            if [ -n "$EXISTING_SHA" ]; then
              curl -s -X PUT -H "Authorization: token $GH_TOKEN" \
                "https://api.github.com/repos/agentivo/overlap/contents/radata.enc" \
                -d "{\"message\":\"backup\",\"content\":\"$CONTENT\",\"sha\":\"$EXISTING_SHA\",\"branch\":\"data\"}" > /dev/null
            else
              curl -s -X PUT -H "Authorization: token $GH_TOKEN" \
                "https://api.github.com/repos/agentivo/overlap/contents/radata.enc" \
                -d "{\"message\":\"backup\",\"content\":\"$CONTENT\",\"branch\":\"data\"}" > /dev/null
            fi

            rm -f radata.enc
            echo "Data backed up"
          }

          cleanup() {
            echo "Uploading data before shutdown..."
            upload_data
            pkill -f "node server.js" || true
            exit 0
          }
          trap cleanup SIGTERM SIGINT EXIT

          generate_app_token() {
            NOW=$(date +%s)
            IAT=$((NOW - 60))
            EXP=$((NOW + 600))

            HEADER=$(echo -n '{"alg":"RS256","typ":"JWT"}' | openssl base64 -e | tr -d '=' | tr '/+' '_-' | tr -d '\n')
            PAYLOAD=$(echo -n "{\"iat\":${IAT},\"exp\":${EXP},\"iss\":\"${APP_ID}\"}" | openssl base64 -e | tr -d '=' | tr '/+' '_-' | tr -d '\n')
            SIGNATURE=$(echo -n "${HEADER}.${PAYLOAD}" | openssl dgst -sha256 -sign <(echo "$APP_PRIVATE_KEY") | openssl base64 -e | tr -d '=' | tr '/+' '_-' | tr -d '\n')

            JWT="${HEADER}.${PAYLOAD}.${SIGNATURE}"

            INSTALLATION_ID=$(curl -s \
              -H "Authorization: Bearer $JWT" \
              -H "Accept: application/vnd.github+json" \
              "https://api.github.com/repos/${{ github.repository }}/installation" | jq -r '.id')

            if [ -z "$INSTALLATION_ID" ] || [ "$INSTALLATION_ID" = "null" ]; then
              return
            fi

            TOKEN_RESPONSE=$(curl -sX POST \
              -H "Authorization: Bearer $JWT" \
              -H "Accept: application/vnd.github+json" \
              -d '{"permissions":{"contents":"write"}}' \
              "https://api.github.com/app/installations/${INSTALLATION_ID}/access_tokens")

            TOKEN=$(echo "$TOKEN_RESPONSE" | jq -r '.token // empty')
            if [ -z "$TOKEN" ] || [ "$TOKEN" = "null" ]; then
              echo "Token error: $(echo "$TOKEN_RESPONSE" | jq -r '.message // "unknown"')" >&2
              return
            fi
            echo "$TOKEN"
          }

          DURATION_HOURS="${{ github.event.client_payload.duration_hours || github.event.inputs.duration_hours || '5' }}"
          DURATION=$(awk "BEGIN {printf \"%.0f\", $DURATION_HOURS * 3600}")
          RESTART_THRESHOLD=$((DURATION - 360))
          START_TIME=$(date +%s)
          RESTART_TRIGGERED=false

          AUTO_RESTART="${{ github.event.client_payload.auto_restart || github.event.inputs.auto_restart }}"
          if [ -z "$AUTO_RESTART" ]; then
            AUTO_RESTART="true"
          fi

          echo "Duration: ${DURATION_HOURS}h | Auto-restart: $AUTO_RESTART"

          LAST_UPLOAD=0
          UPLOAD_INTERVAL=1800  # 30 minutes

          while true; do
            ELAPSED=$(($(date +%s) - START_TIME))
            REMAINING=$((DURATION - ELAPSED))

            if ! curl -sf http://localhost:3000/health > /dev/null; then
              echo "Health check failed, restarting server..."
              pkill -f "node server.js" || true
              node server.js &
              sleep 2
            fi

            # Periodic data backup
            if [ $((ELAPSED - LAST_UPLOAD)) -ge $UPLOAD_INTERVAL ]; then
              echo "Periodic backup..."
              upload_data
              LAST_UPLOAD=$ELAPSED
            fi

            printf "[%s] Overlap running | %dm elapsed | %dm remaining\n" \
              "$(date '+%H:%M:%S')" "$((ELAPSED/60))" "$((REMAINING/60))"

            if [ "$ELAPSED" -gt "$RESTART_THRESHOLD" ] && [ "$RESTART_TRIGGERED" = "false" ]; then
              if [ "$AUTO_RESTART" = "true" ] && [ -n "$APP_ID" ] && [ -n "$APP_PRIVATE_KEY" ]; then
                echo "Uploading data before restart..."
                upload_data

                echo "Generating fresh token and triggering restart..."

                APP_TOKEN=$(generate_app_token)
                if [ -z "$APP_TOKEN" ]; then
                  echo "ERROR: Failed to generate app token"
                  RESTART_TRIGGERED=true
                else
                  RESPONSE=$(curl -sX POST \
                    -H "Accept: application/vnd.github+json" \
                    -H "Authorization: Bearer $APP_TOKEN" \
                    "https://api.github.com/repos/${{ github.repository }}/dispatches" \
                    -d "{\"event_type\":\"restart-deploy\",\"client_payload\":{\"duration_hours\":\"$DURATION_HOURS\",\"auto_restart\":true}}" \
                    -w "\nHTTP_STATUS:%{http_code}" 2>&1)

                  HTTP_CODE=$(echo "$RESPONSE" | grep "HTTP_STATUS:" | cut -d: -f2)

                  if [ "$HTTP_CODE" = "204" ]; then
                    echo "SUCCESS: Restart triggered! Waiting 90s for new instance..."
                    sleep 90
                  else
                    echo "ERROR: Failed to trigger restart (HTTP $HTTP_CODE)"
                  fi

                  RESTART_TRIGGERED=true
                fi
              fi
            fi

            [ "$ELAPSED" -gt "$DURATION" ] && break
            # Interruptible sleep - allows trap to run on signals
            sleep 30 &
            wait $! 2>/dev/null || true
          done

          cleanup
