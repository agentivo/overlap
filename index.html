<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Overlap - Find a time that works for everyone</title>
  <meta name="description" content="Simple availability scheduling. Click and drag to mark when you're free, share the link, find the overlap.">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='10' y='30' width='40' height='40' rx='8' fill='%234caf50' opacity='0.7'/><rect x='50' y='30' width='40' height='40' rx='8' fill='%232196f3' opacity='0.7'/></svg>">
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg: #f5f5f7;
      --bg-card: #ffffff;
      --bg-secondary: #f5f5f7;
      --bg-cell: #fafafa;
      --border: #e5e5e5;
      --border-input: #d2d2d7;
      --text: #1d1d1f;
      --text-secondary: #86868b;
      --shadow: rgba(0,0,0,0.08);
      --toggle-bg: rgba(255,255,255,0.9);
      --tooltip-bg: #1d1d1f;
      --tooltip-text: #ffffff;
    }

    [data-theme="dark"] {
      --bg: #0d0d0d;
      --bg-card: #1a1a1a;
      --bg-secondary: #252525;
      --bg-cell: #1f1f1f;
      --border: #2a2a2a;
      --border-input: #3a3a3a;
      --text: #f5f5f7;
      --text-secondary: #8e8e93;
      --shadow: rgba(0,0,0,0.3);
      --toggle-bg: rgba(0,0,0,0.5);
      --tooltip-bg: #f5f5f7;
      --tooltip-text: #1d1d1f;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
      transition: background 0.3s, color 0.3s;
      user-select: none;
      -webkit-user-select: none;
    }

    input, select {
      user-select: auto;
      -webkit-user-select: auto;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 2rem;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .logo svg {
      width: 32px;
      height: 32px;
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 600;
      color: var(--text);
    }

    .subtitle {
      color: var(--text-secondary);
    }

    .theme-toggle {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      transition: all 0.2s;
    }

    .theme-toggle:hover {
      background: var(--border);
    }

    .theme-toggle svg {
      width: 20px;
      height: 20px;
      transition: all 0.2s;
    }

    .sun-icon {
      fill: none;
      stroke: var(--text-secondary);
      stroke-width: 2;
      stroke-linecap: round;
    }

    .moon-icon {
      fill: var(--text-secondary);
    }

    .panels {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 2rem;
    }

    .sidebar {
      background: var(--bg-card);
      border-radius: 12px;
      padding: 1.5rem;
      height: fit-content;
      box-shadow: 0 1px 3px var(--shadow);
      border: 1px solid var(--border);
    }

    .sidebar h2 {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .form-group {
      margin-bottom: 1.25rem;
    }

    .form-group label {
      display: block;
      font-size: 0.875rem;
      color: var(--text);
      margin-bottom: 0.5rem;
      font-weight: 500;
    }

    .form-group input {
      width: 100%;
      padding: 0.625rem 0.75rem;
      border: 1px solid var(--border-input);
      border-radius: 8px;
      font-size: 0.9375rem;
      transition: border-color 0.2s;
      background: var(--bg-secondary);
      color: var(--text);
    }

    .form-group input:focus {
      outline: none;
      border-color: #0071e3;
    }

    .form-group input::placeholder {
      color: var(--text-secondary);
    }

    .time-range {
      display: flex;
      gap: 0.5rem;
      align-items: center;
      color: var(--text-secondary);
    }

    .time-range select {
      flex: 1;
      padding: 0.625rem 2rem 0.625rem 0.75rem;
      border: 1px solid var(--border-input);
      border-radius: 8px;
      font-size: 0.875rem;
      background: var(--bg-secondary);
      color: var(--text);
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%2386868b' d='M2 4l4 4 4-4'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      cursor: pointer;
    }

    .participants {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid var(--border);
    }

    .participant {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0;
      font-size: 0.875rem;
      color: var(--text);
    }

    .participant-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #34c759;
    }

    .main {
      background: var(--bg-card);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 1px 3px var(--shadow);
      border: 1px solid var(--border);
      overflow-x: auto;
    }

    .grid-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .mode-toggle {
      display: flex;
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 3px;
    }

    .mode-toggle button {
      padding: 0.5rem 1rem;
      border: none;
      background: transparent;
      border-radius: 6px;
      font-size: 0.875rem;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 0.2s;
    }

    .mode-toggle button.active {
      background: var(--bg-card);
      color: var(--text);
      box-shadow: 0 1px 2px var(--shadow);
    }

    .week-nav {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .nav-btn {
      width: 32px;
      height: 32px;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      transition: all 0.2s;
    }

    .nav-btn:hover:not(:disabled) {
      background: var(--border);
    }

    .nav-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .week-label {
      font-size: 0.8125rem;
      color: var(--text-secondary);
      min-width: 100px;
      text-align: center;
    }

    .legend {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .legend-bar {
      width: 100px;
      height: 12px;
      border-radius: 3px;
      background: linear-gradient(to right, #1a3d1a, #4caf50);
    }

    [data-theme="dark"] .legend-bar {
      background: linear-gradient(to right, #1a3d1a, #66bb6a);
    }

    .grid-container {
      position: relative;
      user-select: none;
    }

    .grid {
      display: grid;
      gap: 1px;
      background: var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    .grid-cell {
      background: var(--bg-cell);
      min-height: 24px;
      transition: background-color 0.1s;
      cursor: pointer;
    }

    .grid-cell.header {
      background: var(--bg-secondary);
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.75rem 0.5rem;
      cursor: default;
    }

    .grid-cell.time-label {
      background: var(--bg-secondary);
      font-size: 0.6875rem;
      color: var(--text-secondary);
      display: flex;
      align-items: flex-start;
      justify-content: flex-end;
      padding: 2px 8px 0 0;
      cursor: default;
    }

    .grid-cell.time-label.faded {
      color: var(--text-secondary);
      opacity: 0.5;
      font-size: 0.625rem;
    }

    .grid-cell.available {
      background: #4caf50;
    }

    [data-theme="dark"] .grid-cell.available {
      background: #43a047;
    }

    .grid-cell.available-1 { background: #1b3d1b; }
    .grid-cell.available-2 { background: #234d23; }
    .grid-cell.available-3 { background: #2b5d2b; }
    .grid-cell.available-4 { background: #337033; }
    .grid-cell.available-5 { background: #3b833b; }
    .grid-cell.available-6 { background: #439643; }
    .grid-cell.available-7 { background: #4caf50; }
    .grid-cell.available-8 { background: #5cb85c; }
    .grid-cell.available-9 { background: #66bb6a; }

    [data-theme="light"] .grid-cell.available-1 { background: #e8f5e9; }
    [data-theme="light"] .grid-cell.available-2 { background: #c8e6c9; }
    [data-theme="light"] .grid-cell.available-3 { background: #a5d6a7; }
    [data-theme="light"] .grid-cell.available-4 { background: #81c784; }
    [data-theme="light"] .grid-cell.available-5 { background: #66bb6a; }
    [data-theme="light"] .grid-cell.available-6 { background: #4caf50; }
    [data-theme="light"] .grid-cell.available-7 { background: #43a047; }
    [data-theme="light"] .grid-cell.available-8 { background: #388e3c; }
    [data-theme="light"] .grid-cell.available-9 { background: #2e7d32; }

    .grid-cell:not(.header):not(.time-label):hover {
      filter: brightness(1.1);
    }

    .now-indicator {
      position: absolute;
      left: 60px;
      right: 0;
      height: 2px;
      background: #ef4444;
      pointer-events: none;
      z-index: 10;
    }

    .now-indicator::before {
      content: '';
      position: absolute;
      left: -4px;
      top: -3px;
      width: 8px;
      height: 8px;
      background: #ef4444;
      border-radius: 50%;
    }

    .date-header {
      text-align: center;
    }

    .date-header .day-name {
      font-size: 0.6875rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .date-header .day-num {
      font-size: 1rem;
      font-weight: 600;
    }

    .instructions {
      margin-top: 1rem;
      padding: 1rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      font-size: 0.8125rem;
      color: var(--text-secondary);
    }

    .btn-row {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .btn {
      flex: 1;
      padding: 0.75rem;
      border: none;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background: #0071e3;
      color: white;
    }

    .btn-primary:hover {
      background: #0077ed;
    }

    .btn-secondary {
      background: var(--bg-secondary);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--border);
    }

    .btn-copy {
      background: rgba(76, 175, 80, 0.15);
      color: #4caf50;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .btn-copy:hover {
      background: rgba(76, 175, 80, 0.25);
    }

    .btn-copy.copied {
      background: #4caf50;
      color: white;
      border-color: #4caf50;
    }

    .btn-copy.pulse {
      animation: pulse 0.6s ease-out;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.5); }
      100% { box-shadow: 0 0 0 12px rgba(76, 175, 80, 0); }
    }

    .tooltip {
      position: absolute;
      background: var(--tooltip-bg);
      color: var(--tooltip-text);
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.75rem;
      pointer-events: none;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.15s;
      white-space: nowrap;
    }

    .tooltip.visible {
      opacity: 1;
    }

    @media (max-width: 768px) {
      .panels {
        grid-template-columns: 1fr;
      }

      body {
        padding: 1rem;
      }

      .grid-cell.header {
        padding: 0.5rem 0.25rem;
      }

      .date-header .day-num {
        font-size: 0.875rem;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <div class="logo">
          <svg viewBox="0 0 100 100" fill="none">
            <rect x="10" y="30" width="40" height="40" rx="8" fill="#4caf50" opacity="0.7"/>
            <rect x="50" y="30" width="40" height="40" rx="8" fill="#2196f3" opacity="0.7"/>
          </svg>
          <h1>Overlap</h1>
        </div>
        <p class="subtitle">Find a time that works for everyone</p>
      </div>
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <svg class="sun-icon" viewBox="0 0 24 24" style="display: none;">
          <circle cx="12" cy="12" r="4"/>
          <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"/>
        </svg>
        <svg class="moon-icon" viewBox="0 0 24 24">
          <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/>
        </svg>
      </button>
    </header>

    <div class="panels">
      <div class="sidebar">
        <h2>Your Info</h2>
        <div class="form-group">
          <label>Your Name</label>
          <input type="text" id="userName" placeholder="Your name (required)">
        </div>

        <h2>Time Range</h2>
        <div class="form-group">
          <label>Available hours</label>
          <div class="time-range">
            <select id="startTime"></select>
            <span>to</span>
            <select id="endTime"></select>
          </div>
        </div>

        <div class="btn-row">
          <button class="btn btn-secondary" onclick="clearMyAvailability()">Clear</button>
          <button class="btn btn-copy" id="copyBtn" onclick="copyLink()">Share Link</button>
        </div>

        <div class="participants">
          <h2>Participants</h2>
          <div id="participantList">
            <p style="font-size: 0.8125rem; color: var(--text-secondary);">No one yet</p>
          </div>
        </div>
      </div>

      <div class="main">
        <div class="grid-header">
          <div class="mode-toggle">
            <button class="active" onclick="setMode('edit')">Edit</button>
            <button onclick="setMode('view')">View Group</button>
          </div>
          <div class="week-nav">
            <button class="nav-btn" id="prevWeek" onclick="prevWeek()" disabled>◀</button>
            <span class="week-label" id="weekLabel"></span>
            <button class="nav-btn" id="nextWeek" onclick="nextWeek()">▶</button>
          </div>
          <div class="legend">
            <span>None</span>
            <div class="legend-bar"></div>
            <span>All</span>
          </div>
        </div>

        <div class="grid-container">
          <div class="grid" id="grid"></div>
          <div class="tooltip" id="tooltip"></div>
          <div class="now-indicator" id="nowIndicator" style="display: none;"></div>
        </div>

        <div class="instructions">
          <span id="timezoneDisplay"></span>
          Enter your name above, then click and drag to mark when you're free.
        </div>
      </div>
    </div>
  </div>

  <script>
    // LZ-string compression (minimal implementation for URI-safe encoding)
    const LZ = (() => {
      const keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_';

      function compressToEncodedURIComponent(input) {
        if (input == null) return '';
        return _compress(input, 6, (a) => keyStr.charAt(a));
      }

      function decompressFromEncodedURIComponent(input) {
        if (input == null) return '';
        if (input === '') return null;
        return _decompress(input.length, 32, (index) => {
          const val = keyStr.indexOf(input.charAt(index));
          return val === -1 ? undefined : val;
        });
      }

      function _compress(uncompressed, bitsPerChar, getCharFromInt) {
        let i, value, context_dictionary = {}, context_dictionaryToCreate = {},
          context_c = '', context_wc = '', context_w = '', context_enlargeIn = 2,
          context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0,
          context_data_position = 0;

        for (let ii = 0; ii < uncompressed.length; ii++) {
          context_c = uncompressed.charAt(ii);
          if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
            context_dictionary[context_c] = context_dictSize++;
            context_dictionaryToCreate[context_c] = true;
          }
          context_wc = context_w + context_c;
          if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
            context_w = context_wc;
          } else {
            if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
              if (context_w.charCodeAt(0) < 256) {
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = (context_data_val << 1);
                  if (context_data_position === bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else context_data_position++;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 8; i++) {
                  context_data_val = (context_data_val << 1) | (value & 1);
                  if (context_data_position === bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else context_data_position++;
                  value = value >> 1;
                }
              } else {
                value = 1;
                for (i = 0; i < context_numBits; i++) {
                  context_data_val = (context_data_val << 1) | value;
                  if (context_data_position === bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else context_data_position++;
                  value = 0;
                }
                value = context_w.charCodeAt(0);
                for (i = 0; i < 16; i++) {
                  context_data_val = (context_data_val << 1) | (value & 1);
                  if (context_data_position === bitsPerChar - 1) {
                    context_data_position = 0;
                    context_data.push(getCharFromInt(context_data_val));
                    context_data_val = 0;
                  } else context_data_position++;
                  value = value >> 1;
                }
              }
              context_enlargeIn--;
              if (context_enlargeIn === 0) {
                context_enlargeIn = Math.pow(2, context_numBits);
                context_numBits++;
              }
              delete context_dictionaryToCreate[context_w];
            } else {
              value = context_dictionary[context_w];
              for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position === bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else context_data_position++;
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn === 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            context_dictionary[context_wc] = context_dictSize++;
            context_w = String(context_c);
          }
        }
        if (context_w !== '') {
          if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
            if (context_w.charCodeAt(0) < 256) {
              for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1);
                if (context_data_position === bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else context_data_position++;
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 8; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position === bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else context_data_position++;
                value = value >> 1;
              }
            } else {
              value = 1;
              for (i = 0; i < context_numBits; i++) {
                context_data_val = (context_data_val << 1) | value;
                if (context_data_position === bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else context_data_position++;
                value = 0;
              }
              value = context_w.charCodeAt(0);
              for (i = 0; i < 16; i++) {
                context_data_val = (context_data_val << 1) | (value & 1);
                if (context_data_position === bitsPerChar - 1) {
                  context_data_position = 0;
                  context_data.push(getCharFromInt(context_data_val));
                  context_data_val = 0;
                } else context_data_position++;
                value = value >> 1;
              }
            }
            context_enlargeIn--;
            if (context_enlargeIn === 0) {
              context_enlargeIn = Math.pow(2, context_numBits);
              context_numBits++;
            }
            delete context_dictionaryToCreate[context_w];
          } else {
            value = context_dictionary[context_w];
            for (i = 0; i < context_numBits; i++) {
              context_data_val = (context_data_val << 1) | (value & 1);
              if (context_data_position === bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else context_data_position++;
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn === 0) {
            context_numBits++;
          }
        }
        value = 2;
        for (i = 0; i < context_numBits; i++) {
          context_data_val = (context_data_val << 1) | (value & 1);
          if (context_data_position === bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else context_data_position++;
          value = value >> 1;
        }
        while (true) {
          context_data_val = (context_data_val << 1);
          if (context_data_position === bitsPerChar - 1) {
            context_data.push(getCharFromInt(context_data_val));
            break;
          } else context_data_position++;
        }
        return context_data.join('');
      }

      function _decompress(length, resetValue, getNextValue) {
        let dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3,
          entry = '', result = [], w, c, data = { val: getNextValue(0), position: resetValue, index: 1 };

        function readBits(numBits) {
          let bits = 0, power = 1;
          for (let i = 0; i < numBits; i++) {
            const resb = data.val & data.position;
            data.position >>= 1;
            if (data.position === 0) {
              data.position = resetValue;
              data.val = getNextValue(data.index++);
              if (data.val === undefined) return -1;
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          return bits;
        }

        for (let i = 0; i < 3; i++) dictionary[i] = i;

        const firstBits = readBits(2);
        if (firstBits === -1) return null;
        switch (firstBits) {
          case 0: c = String.fromCharCode(readBits(8)); break;
          case 1: c = String.fromCharCode(readBits(16)); break;
          case 2: return '';
        }
        dictionary[3] = c;
        w = c;
        result.push(c);

        while (true) {
          if (data.index > length) return '';
          let cc = readBits(numBits);
          if (cc === -1) return null;
          switch (cc) {
            case 0: c = String.fromCharCode(readBits(8)); dictionary[dictSize++] = c; cc = dictSize - 1; enlargeIn--; break;
            case 1: c = String.fromCharCode(readBits(16)); dictionary[dictSize++] = c; cc = dictSize - 1; enlargeIn--; break;
            case 2: return result.join('');
          }
          if (enlargeIn === 0) { enlargeIn = Math.pow(2, numBits); numBits++; }
          if (dictionary[cc]) entry = dictionary[cc];
          else if (cc === dictSize) entry = w + w.charAt(0);
          else return null;
          result.push(entry);
          dictionary[dictSize++] = w + entry.charAt(0);
          enlargeIn--;
          if (enlargeIn === 0) { enlargeIn = Math.pow(2, numBits); numBits++; }
          w = entry;
        }
      }

      return { compressToEncodedURIComponent, decompressFromEncodedURIComponent };
    })();

    // Theme
    function initTheme() {
      const saved = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const theme = saved || (prefersDark ? 'dark' : 'light');
      setTheme(theme);

      // Listen for system theme changes
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
        if (!localStorage.getItem('theme')) {
          setTheme(e.matches ? 'dark' : 'light');
        }
      });
    }

    function setTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
      updateThemeIcon(theme);
    }

    function toggleTheme() {
      const current = document.documentElement.getAttribute('data-theme');
      setTheme(current === 'dark' ? 'light' : 'dark');
    }

    function updateThemeIcon(theme) {
      const sunIcon = document.querySelector('.sun-icon');
      const moonIcon = document.querySelector('.moon-icon');
      if (theme === 'dark') {
        sunIcon.style.display = 'block';
        moonIcon.style.display = 'none';
      } else {
        sunIcon.style.display = 'none';
        moonIcon.style.display = 'block';
      }
    }

    // State
    let mode = 'edit';
    let isMouseDown = false;
    let isAdding = true;
    let startHour = 9;
    let endHour = 17;
    let days = [];
    let myAvailability = new Set();
    let allParticipants = {};
    let eventTimezone = null;
    let lastCell = null;
    let weekOffset = 0;

    // Timezone lookup table (common timezones)
    const TIMEZONES = [
      'UTC', 'America/New_York', 'America/Chicago', 'America/Denver', 'America/Los_Angeles',
      'America/Toronto', 'America/Vancouver', 'America/Mexico_City', 'America/Sao_Paulo',
      'Europe/London', 'Europe/Paris', 'Europe/Berlin', 'Europe/Madrid', 'Europe/Rome',
      'Europe/Amsterdam', 'Europe/Brussels', 'Europe/Zurich', 'Europe/Stockholm', 'Europe/Warsaw',
      'Europe/Lisbon', 'Europe/Dublin', 'Europe/Vienna', 'Europe/Prague', 'Europe/Budapest',
      'Asia/Tokyo', 'Asia/Shanghai', 'Asia/Hong_Kong', 'Asia/Singapore', 'Asia/Seoul',
      'Asia/Kolkata', 'Asia/Dubai', 'Asia/Bangkok', 'Asia/Jakarta', 'Asia/Manila',
      'Australia/Sydney', 'Australia/Melbourne', 'Australia/Brisbane', 'Australia/Perth',
      'Pacific/Auckland', 'Pacific/Honolulu', 'Africa/Cairo', 'Africa/Johannesburg'
    ];

    function getTimezoneIndex(tz) {
      const idx = TIMEZONES.indexOf(tz);
      return idx >= 0 ? idx : null;
    }

    function getTimezoneByIndex(idx) {
      return TIMEZONES[idx] || null;
    }

    // Timezone
    function getLocalTimezone() {
      return Intl.DateTimeFormat().resolvedOptions().timeZone;
    }

    function formatTimezone(tz) {
      try {
        const name = tz.replace(/_/g, ' ');
        const offset = new Date().toLocaleString('en-US', { timeZone: tz, timeZoneName: 'shortOffset' }).split(' ').pop();
        return `${name} (${offset})`;
      } catch {
        return tz;
      }
    }

    // Compact encoding helpers
    function cellIdToSlot(cellId) {
      const [day, hour, quarter] = cellId.split('-').map(Number);
      return day * 96 + hour * 4 + quarter;
    }

    function slotToCellId(slot) {
      const day = Math.floor(slot / 96);
      const remainder = slot % 96;
      const hour = Math.floor(remainder / 4);
      const quarter = remainder % 4;
      return `${day}-${hour}-${quarter}`;
    }

    function encodeRanges(slots) {
      if (slots.length === 0) return '';
      const sorted = [...slots].sort((a, b) => a - b);
      const ranges = [];
      let start = sorted[0], len = 1;

      for (let i = 1; i < sorted.length; i++) {
        if (sorted[i] === sorted[i-1] + 1) {
          len++;
        } else {
          ranges.push(len === 1 ? `${start}` : `${start}-${len}`);
          start = sorted[i];
          len = 1;
        }
      }
      ranges.push(len === 1 ? `${start}` : `${start}-${len}`);
      return ranges.join(',');
    }

    function decodeRanges(str) {
      if (!str) return [];
      const slots = [];
      str.split(',').forEach(part => {
        if (part.includes('-')) {
          const [start, len] = part.split('-').map(Number);
          for (let i = 0; i < len; i++) slots.push(start + i);
        } else {
          slots.push(Number(part));
        }
      });
      return slots;
    }

    // Binary encoding with base64url
    function encodeBinary(tz, participants) {
      const bytes = [];

      // Timezone (1 byte index, or 255 + length + string)
      const tzIdx = getTimezoneIndex(tz);
      if (tzIdx !== null) {
        bytes.push(tzIdx);
      } else {
        bytes.push(255);
        const tzBytes = new TextEncoder().encode(tz);
        bytes.push(tzBytes.length);
        bytes.push(...tzBytes);
      }

      // Participants
      const entries = Object.entries(participants);
      bytes.push(entries.length);

      entries.forEach(([name, cellIds]) => {
        const nameBytes = new TextEncoder().encode(name);
        bytes.push(nameBytes.length);
        bytes.push(...nameBytes);

        // Convert to slots and get ranges
        const slots = Array.from(cellIds).map(cellIdToSlot).sort((a, b) => a - b);
        const ranges = [];
        if (slots.length > 0) {
          let start = slots[0], len = 1;
          for (let i = 1; i < slots.length; i++) {
            if (slots[i] === slots[i-1] + 1) {
              len++;
            } else {
              ranges.push([start, len]);
              start = slots[i];
              len = 1;
            }
          }
          ranges.push([start, len]);
        }

        // Number of ranges (2 bytes)
        bytes.push(ranges.length & 0xFF);
        bytes.push((ranges.length >> 8) & 0xFF);

        // Each range: start (2 bytes) + length (1 byte)
        ranges.forEach(([start, len]) => {
          bytes.push(start & 0xFF);
          bytes.push((start >> 8) & 0xFF);
          bytes.push(len);
        });
      });

      return base64UrlEncode(new Uint8Array(bytes));
    }

    function decodeBinary(str) {
      const bytes = base64UrlDecode(str);
      let pos = 0;

      // Timezone
      let tz;
      const tzIdx = bytes[pos++];
      if (tzIdx === 255) {
        const tzLen = bytes[pos++];
        tz = new TextDecoder().decode(bytes.slice(pos, pos + tzLen));
        pos += tzLen;
      } else {
        tz = getTimezoneByIndex(tzIdx) || getLocalTimezone();
      }

      // Participants
      const numParticipants = bytes[pos++];
      const participants = {};

      for (let i = 0; i < numParticipants; i++) {
        const nameLen = bytes[pos++];
        const name = new TextDecoder().decode(bytes.slice(pos, pos + nameLen));
        pos += nameLen;

        const numRanges = bytes[pos] | (bytes[pos + 1] << 8);
        pos += 2;

        const cellIds = new Set();
        for (let r = 0; r < numRanges; r++) {
          const start = bytes[pos] | (bytes[pos + 1] << 8);
          pos += 2;
          const len = bytes[pos++];
          for (let s = 0; s < len; s++) {
            cellIds.add(slotToCellId(start + s));
          }
        }

        participants[name] = cellIds;
      }

      return { tz, participants };
    }

    function base64UrlEncode(uint8Array) {
      let binary = '';
      uint8Array.forEach(b => binary += String.fromCharCode(b));
      return btoa(binary).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    }

    function base64UrlDecode(str) {
      str = str.replace(/-/g, '+').replace(/_/g, '/');
      while (str.length % 4) str += '=';
      const binary = atob(str);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
      return bytes;
    }

    // Legacy compact format (for backward compatibility)
    function encodeCompact(tz, participants) {
      const tzIdx = getTimezoneIndex(tz);
      const tzPart = tzIdx !== null ? tzIdx : `~${tz}`;

      const parts = [tzPart];
      Object.entries(participants).forEach(([name, cellIds]) => {
        const slots = Array.from(cellIds).map(cellIdToSlot);
        const encoded = encodeRanges(slots);
        parts.push(`${encodeURIComponent(name)}:${encoded}`);
      });

      return parts.join('|');
    }

    function decodeCompact(str) {
      const parts = str.split('|');
      const tzPart = parts[0];

      let tz;
      if (tzPart.startsWith('~')) {
        tz = tzPart.slice(1);
      } else {
        tz = getTimezoneByIndex(Number(tzPart)) || getLocalTimezone();
      }

      const participants = {};
      for (let i = 1; i < parts.length; i++) {
        const colonIdx = parts[i].indexOf(':');
        if (colonIdx === -1) continue;
        const name = decodeURIComponent(parts[i].slice(0, colonIdx));
        const rangesStr = parts[i].slice(colonIdx + 1);
        const slots = decodeRanges(rangesStr);
        participants[name] = new Set(slots.map(slotToCellId));
      }

      return { tz, participants };
    }

    function updateTimezoneDisplay() {
      const display = document.getElementById('timezoneDisplay');
      const localTz = getLocalTimezone();

      if (eventTimezone && eventTimezone !== localTz) {
        display.innerHTML = `<strong>Times shown in ${formatTimezone(eventTimezone)}</strong> · Your timezone: ${formatTimezone(localTz)}<br><br>`;
      } else {
        display.innerHTML = `Times shown in ${formatTimezone(localTz)}<br><br>`;
      }
    }

    // Generate 7 days starting from offset
    function generateDays() {
      const today = new Date();
      days = [];
      for (let i = 0; i < 7; i++) {
        const date = new Date(today);
        date.setDate(today.getDate() + weekOffset * 7 + i);
        days.push(date);
      }
    }

    function prevWeek() {
      if (weekOffset > 0) {
        weekOffset--;
        generateDays();
        renderGrid();
        updateNowIndicator();
        updateWeekNav();
      }
    }

    function nextWeek() {
      weekOffset++;
      generateDays();
      renderGrid();
      updateNowIndicator();
      updateWeekNav();
    }

    function updateWeekNav() {
      document.getElementById('prevWeek').disabled = weekOffset === 0;

      const startDate = days[0];
      const endDate = days[days.length - 1];
      const opts = { month: 'short', day: 'numeric' };
      const start = startDate.toLocaleDateString('en-US', opts);
      const end = endDate.toLocaleDateString('en-US', opts);
      document.getElementById('weekLabel').textContent = `${start} – ${end}`;
    }

    // Populate time selectors
    function populateTimeSelectors() {
      const startSelect = document.getElementById('startTime');
      const endSelect = document.getElementById('endTime');

      for (let h = 0; h < 24; h++) {
        const label = formatHour(h);
        startSelect.options.add(new Option(label, h));
        endSelect.options.add(new Option(label, h));
      }

      startSelect.value = startHour;
      endSelect.value = endHour;

      startSelect.onchange = () => {
        startHour = parseInt(startSelect.value);
        renderGrid();
        updateNowIndicator();
      };
      endSelect.onchange = () => {
        endHour = parseInt(endSelect.value);
        renderGrid();
        updateNowIndicator();
      };
    }

    function formatHour(h) {
      if (h === 0) return '12 AM';
      if (h < 12) return h + ' AM';
      if (h === 12) return '12 PM';
      return (h - 12) + ' PM';
    }

    function formatDayName(date) {
      return date.toLocaleDateString('en-US', { weekday: 'short' });
    }

    function formatDayNum(date) {
      return date.getDate();
    }

    function getCellId(dayIndex, hour, quarter) {
      return `${dayIndex}-${hour}-${quarter}`;
    }

    function renderGrid() {
      const grid = document.getElementById('grid');
      const numSlots = (endHour - startHour) * 4;

      if (numSlots <= 0) return;

      grid.style.gridTemplateColumns = `60px repeat(${days.length}, 1fr)`;
      grid.innerHTML = '';

      // Header row
      const cornerCell = document.createElement('div');
      cornerCell.className = 'grid-cell header';
      grid.appendChild(cornerCell);

      days.forEach(date => {
        const headerCell = document.createElement('div');
        headerCell.className = 'grid-cell header';
        headerCell.innerHTML = `
          <div class="date-header">
            <div class="day-name">${formatDayName(date)}</div>
            <div class="day-num">${formatDayNum(date)}</div>
          </div>
        `;
        grid.appendChild(headerCell);
      });

      // Time slots
      for (let h = startHour; h < endHour; h++) {
        for (let q = 0; q < 4; q++) {
          // Time label
          const timeCell = document.createElement('div');
          timeCell.className = 'grid-cell time-label';
          if (q === 0) {
            timeCell.textContent = formatHour(h);
          } else {
            timeCell.textContent = ':' + (q * 15);
            timeCell.classList.add('faded');
          }
          grid.appendChild(timeCell);

          // Day cells
          days.forEach((date, dayIndex) => {
            const cell = document.createElement('div');
            const cellId = getCellId(dayIndex, h, q);
            cell.className = 'grid-cell';
            cell.dataset.cellId = cellId;
            cell.dataset.day = dayIndex;
            cell.dataset.hour = h;
            cell.dataset.quarter = q;

            cell.addEventListener('mousedown', onCellMouseDown);
            cell.addEventListener('mouseenter', onCellMouseEnter);
            cell.addEventListener('touchstart', onCellTouchStart, { passive: false });
            cell.addEventListener('touchmove', onCellTouchMove, { passive: false });

            grid.appendChild(cell);
          });
        }
      }

      updateGridDisplay();
    }

    function onCellMouseDown(e) {
      if (mode !== 'edit') return;
      isMouseDown = true;
      const cell = e.target;
      const cellId = cell.dataset.cellId;
      isAdding = !myAvailability.has(cellId);
      lastCell = { day: parseInt(cell.dataset.day), hour: parseInt(cell.dataset.hour), quarter: parseInt(cell.dataset.quarter) };
      toggleCell(cellId);
    }

    function onCellMouseEnter(e) {
      if (!isMouseDown || mode !== 'edit') return;
      const cell = e.target;
      const currentCell = { day: parseInt(cell.dataset.day), hour: parseInt(cell.dataset.hour), quarter: parseInt(cell.dataset.quarter) };

      if (lastCell) {
        fillCellsBetween(lastCell, currentCell);
      }

      lastCell = currentCell;
      toggleCell(cell.dataset.cellId);
    }

    function fillCellsBetween(from, to) {
      const minDay = Math.min(from.day, to.day);
      const maxDay = Math.max(from.day, to.day);
      const fromSlot = from.hour * 4 + from.quarter;
      const toSlot = to.hour * 4 + to.quarter;
      const minSlot = Math.min(fromSlot, toSlot);
      const maxSlot = Math.max(fromSlot, toSlot);

      // Fill rectangle between from and to
      for (let day = minDay; day <= maxDay; day++) {
        for (let slot = minSlot; slot <= maxSlot; slot++) {
          const hour = Math.floor(slot / 4);
          const quarter = slot % 4;
          const cellId = getCellId(day, hour, quarter);
          if (isAdding) {
            myAvailability.add(cellId);
          } else {
            myAvailability.delete(cellId);
          }
        }
      }
    }

    function onCellTouchStart(e) {
      if (mode !== 'edit') return;
      e.preventDefault();
      isMouseDown = true;
      const touch = e.touches[0];
      const cell = document.elementFromPoint(touch.clientX, touch.clientY);
      if (cell && cell.dataset.cellId) {
        isAdding = !myAvailability.has(cell.dataset.cellId);
        lastCell = { day: parseInt(cell.dataset.day), hour: parseInt(cell.dataset.hour), quarter: parseInt(cell.dataset.quarter) };
        toggleCell(cell.dataset.cellId);
      }
    }

    function onCellTouchMove(e) {
      if (!isMouseDown || mode !== 'edit') return;
      e.preventDefault();
      const touch = e.touches[0];
      const cell = document.elementFromPoint(touch.clientX, touch.clientY);
      if (cell && cell.dataset.cellId) {
        const currentCell = { day: parseInt(cell.dataset.day), hour: parseInt(cell.dataset.hour), quarter: parseInt(cell.dataset.quarter) };
        if (lastCell) {
          fillCellsBetween(lastCell, currentCell);
        }
        lastCell = currentCell;
        toggleCell(cell.dataset.cellId);
      }
    }

    function toggleCell(cellId) {
      if (!cellId) return;

      // Require name before selecting
      const nameInput = document.getElementById('userName');
      const name = nameInput.value.trim();
      if (!name) {
        nameInput.focus();
        isMouseDown = false;
        return;
      }

      if (isAdding) {
        myAvailability.add(cellId);
      } else {
        myAvailability.delete(cellId);
      }
      updateGridDisplay();
      autoSave();
    }

    function autoSave() {
      const name = document.getElementById('userName').value.trim();
      if (!name) return;

      // Set timezone on first save
      if (!eventTimezone) {
        eventTimezone = getLocalTimezone();
        updateTimezoneDisplay();
      }

      allParticipants[name] = new Set(myAvailability);
      updateParticipantList();
      updateURL();
      pulseCopyButton();
    }

    function pulseCopyButton() {
      const btn = document.getElementById('copyBtn');
      btn.classList.remove('pulse');
      // Trigger reflow to restart animation
      void btn.offsetWidth;
      btn.classList.add('pulse');
    }

    document.addEventListener('mouseup', () => {
      isMouseDown = false;
      lastCell = null;
    });

    document.addEventListener('touchend', () => {
      isMouseDown = false;
      lastCell = null;
    });

    function updateGridDisplay() {
      const cells = document.querySelectorAll('.grid-cell[data-cell-id]');
      const tooltip = document.getElementById('tooltip');

      if (mode === 'edit') {
        cells.forEach(cell => {
          const cellId = cell.dataset.cellId;
          cell.className = 'grid-cell' + (myAvailability.has(cellId) ? ' available' : '');
        });
      } else {
        // View mode - show aggregate
        const participantCount = Object.keys(allParticipants).length;
        cells.forEach(cell => {
          const cellId = cell.dataset.cellId;
          let count = 0;
          Object.values(allParticipants).forEach(slots => {
            if (slots.has(cellId)) count++;
          });

          cell.className = 'grid-cell';
          if (count > 0 && participantCount > 0) {
            const level = Math.ceil((count / participantCount) * 9);
            cell.classList.add(`available-${level}`);
          }

          // Add hover for tooltip
          cell.onmouseenter = (e) => {
            if (mode !== 'view') return;
            const names = [];
            Object.entries(allParticipants).forEach(([name, slots]) => {
              if (slots.has(cellId)) names.push(name);
            });
            if (names.length > 0) {
              tooltip.textContent = names.join(', ');
              tooltip.classList.add('visible');
              const rect = cell.getBoundingClientRect();
              const containerRect = cell.closest('.grid-container').getBoundingClientRect();
              tooltip.style.left = Math.max(0, rect.left - containerRect.left + rect.width / 2 - tooltip.offsetWidth / 2) + 'px';
              tooltip.style.top = (rect.top - containerRect.top - tooltip.offsetHeight - 8) + 'px';
            }
          };
          cell.onmouseleave = () => {
            tooltip.classList.remove('visible');
          };
        });
      }
    }

    function setMode(newMode) {
      mode = newMode;
      document.querySelectorAll('.mode-toggle button').forEach((btn, i) => {
        btn.classList.toggle('active', (i === 0 && mode === 'edit') || (i === 1 && mode === 'view'));
      });
      updateGridDisplay();
    }

    function clearMyAvailability() {
      myAvailability.clear();
      updateGridDisplay();
      autoSave();
    }

    function updateParticipantList() {
      const list = document.getElementById('participantList');
      const names = Object.keys(allParticipants);

      if (names.length === 0) {
        list.innerHTML = '<p style="font-size: 0.8125rem; color: var(--text-secondary);">No one yet</p>';
        return;
      }

      list.innerHTML = '';
      names.forEach(name => {
        const div = document.createElement('div');
        div.className = 'participant';
        div.innerHTML = `<span class="participant-dot"></span>${name}`;
        list.appendChild(div);
      });
    }

    function updateURL() {
      const tz = eventTimezone || getLocalTimezone();
      const binary = encodeBinary(tz, allParticipants);
      history.replaceState(null, '', '?d=' + binary);
    }

    function loadFromURL() {
      const params = new URLSearchParams(window.location.search);
      const encoded = params.get('d');

      if (!encoded) return;

      try {
        // Try binary format first (base64url characters only)
        if (/^[A-Za-z0-9_-]+$/.test(encoded)) {
          try {
            const { tz, participants } = decodeBinary(encoded);
            eventTimezone = tz;
            Object.assign(allParticipants, participants);
            return;
          } catch (e) {
            // Not binary, try other formats
          }
        }

        // Legacy: compact format (starts with number or ~)
        if (/^(\d+|~)/.test(encoded)) {
          const { tz, participants } = decodeCompact(encoded);
          eventTimezone = tz;
          Object.assign(allParticipants, participants);
          return;
        }

        // Legacy: LZ decompression
        let jsonStr = LZ.decompressFromEncodedURIComponent(encoded);

        // Legacy: old base64 format
        if (!jsonStr || jsonStr.charAt(0) !== '{') {
          jsonStr = decodeURIComponent(atob(encoded));
        }

        const data = JSON.parse(jsonStr);
        if (data.tz) {
          eventTimezone = data.tz;
          Object.entries(data.p || {}).forEach(([name, slots]) => {
            allParticipants[name] = new Set(slots);
          });
        } else {
          Object.entries(data).forEach(([name, slots]) => {
            allParticipants[name] = new Set(slots);
          });
        }
      } catch (e) {
        console.error('Failed to load data from URL');
      }
    }

    function copyLink() {
      const btn = document.getElementById('copyBtn');
      navigator.clipboard.writeText(window.location.href).then(() => {
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => {
          btn.textContent = 'Share Link';
          btn.classList.remove('copied');
        }, 2000);
      });
    }

    // Current time indicator
    function updateNowIndicator() {
      const indicator = document.getElementById('nowIndicator');
      const grid = document.getElementById('grid');
      const now = new Date();

      // Check if today is in the visible days (day 0)
      const today = new Date();
      today.setHours(0, 0, 0, 0);
      const firstDay = new Date(days[0]);
      firstDay.setHours(0, 0, 0, 0);

      if (today.getTime() !== firstDay.getTime()) {
        indicator.style.display = 'none';
        return;
      }

      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();

      // Check if current time is in visible range
      if (currentHour < startHour || currentHour >= endHour) {
        indicator.style.display = 'none';
        return;
      }

      // Calculate position
      const headerHeight = grid.querySelector('.grid-cell.header')?.offsetHeight || 0;
      const cellHeight = 24; // min-height of cells
      const gap = 1; // grid gap

      const slotsFromStart = (currentHour - startHour) * 4 + Math.floor(currentMinute / 15);
      const minuteOffset = (currentMinute % 15) / 15 * (cellHeight + gap);
      const topPosition = headerHeight + gap + slotsFromStart * (cellHeight + gap) + minuteOffset;

      indicator.style.display = 'block';
      indicator.style.top = topPosition + 'px';
    }

    // Auto-focus name input when typing
    document.addEventListener('keydown', (e) => {
      const nameInput = document.getElementById('userName');
      if (document.activeElement !== nameInput &&
          !e.ctrlKey && !e.metaKey && !e.altKey &&
          e.key.length === 1) {
        nameInput.focus();
      }
    });

    // Initialize
    initTheme();
    generateDays();
    populateTimeSelectors();
    loadFromURL();
    renderGrid();
    updateParticipantList();
    updateTimezoneDisplay();
    updateNowIndicator();
    updateWeekNav();
    setInterval(updateNowIndicator, 60000); // Update every minute

    // Auto-focus name input on load
    document.getElementById('userName').focus();
  </script>
</body>
</html>
