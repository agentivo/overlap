<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Overlap - Find a time that works for everyone</title>
  <meta name="description" content="Simple availability scheduling. Click and drag to mark when you're free, share the link, find the overlap.">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='10' y='30' width='40' height='40' rx='8' fill='%234caf50' opacity='0.7'/><rect x='50' y='30' width='40' height='40' rx='8' fill='%232196f3' opacity='0.7'/></svg>">
  <script src="https://cdn.jsdelivr.net/npm/gun/gun.js"></script>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --bg: #f5f5f7;
      --bg-card: #ffffff;
      --bg-secondary: #f5f5f7;
      --bg-cell: #fafafa;
      --border: #e5e5e5;
      --border-input: #d2d2d7;
      --text: #1d1d1f;
      --text-secondary: #86868b;
      --shadow: rgba(0,0,0,0.08);
      --toggle-bg: rgba(255,255,255,0.9);
      --tooltip-bg: #1d1d1f;
      --tooltip-text: #ffffff;
    }

    [data-theme="dark"] {
      --bg: #0d0d0d;
      --bg-card: #1a1a1a;
      --bg-secondary: #252525;
      --bg-cell: #1f1f1f;
      --border: #2a2a2a;
      --border-input: #3a3a3a;
      --text: #f5f5f7;
      --text-secondary: #8e8e93;
      --shadow: rgba(0,0,0,0.3);
      --toggle-bg: rgba(0,0,0,0.5);
      --tooltip-bg: #f5f5f7;
      --tooltip-text: #1d1d1f;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
      user-select: none;
      -webkit-user-select: none;
    }

    input, select {
      user-select: auto;
      -webkit-user-select: auto;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 2rem;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.5rem;
    }

    .logo svg {
      width: 32px;
      height: 32px;
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 600;
      color: var(--text);
    }

    .event-title {
      font-size: 1.125rem;
      font-weight: 600;
      color: var(--text);
      background: transparent;
      border: none;
      border-bottom: 1px dashed transparent;
      padding: 0 0 0.25rem 0;
      margin-bottom: 1rem;
      width: 100%;
      transition: border-color 0.2s;
    }

    .event-title:hover {
      border-bottom-color: var(--border);
    }

    .event-title:focus {
      outline: none;
      border-bottom-color: var(--text-secondary);
    }

    .event-title::placeholder {
      color: var(--text-secondary);
      font-weight: 400;
    }

    .subtitle {
      color: var(--text-secondary);
      font-size: 0.8125rem;
      margin-top: 0.25rem;
    }

    .theme-toggle {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 20px;
      padding: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 40px;
      height: 40px;
      transition: all 0.2s;
    }

    .theme-toggle:hover {
      background: var(--border);
    }

    .theme-toggle svg {
      width: 20px;
      height: 20px;
    }

    .sun-icon {
      fill: none;
      stroke: var(--text-secondary);
      stroke-width: 2;
      stroke-linecap: round;
    }

    .moon-icon {
      fill: var(--text-secondary);
    }

    .panels {
      display: grid;
      grid-template-columns: 280px 1fr;
      gap: 2rem;
    }

    .sidebar {
      background: var(--bg-card);
      border-radius: 12px;
      padding: 1.5rem;
      height: fit-content;
      box-shadow: 0 1px 3px var(--shadow);
      border: 1px solid var(--border);
    }

    .sidebar h2 {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 1rem;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .form-group {
      margin-bottom: 1.25rem;
    }

    .form-group label {
      display: block;
      font-size: 0.875rem;
      color: var(--text);
      margin-bottom: 0.5rem;
      font-weight: 500;
    }

    .form-group input {
      width: 100%;
      padding: 0.625rem 0.75rem;
      border: 1px solid var(--border-input);
      border-radius: 8px;
      font-size: 0.9375rem;
      transition: border-color 0.2s;
      background: var(--bg-secondary);
      color: var(--text);
    }

    .form-group input:focus {
      outline: none;
      border-color: #0071e3;
    }

    button:focus,
    button:active,
    .range-slider input:focus {
      outline: none;
    }

    button:active {
      transform: none;
    }

    .form-group input.shake {
      animation: shake 0.5s ease-in-out;
      border-color: #ef4444;
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      20%, 60% { transform: translateX(-4px); }
      40%, 80% { transform: translateX(4px); }
    }

    .form-group input::placeholder {
      color: var(--text-secondary);
    }

    .range-label {
      color: var(--text-secondary);
      font-weight: 400;
      font-size: 0.8125rem;
    }

    .range-slider {
      position: relative;
      height: 24px;
      margin: 8px 0;
    }

    .range-track {
      position: absolute;
      height: 2px;
      background: var(--border);
      border-radius: 1px;
      left: 6px;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
    }

    .range-highlight {
      position: absolute;
      height: 2px;
      background: #4caf50;
      border-radius: 1px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
    }

    .range-slider input[type="range"] {
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      transform: translateY(-50%);
      width: 100%;
      height: 24px;
      background: transparent;
      pointer-events: none;
      -webkit-appearance: none;
      appearance: none;
      margin: 0;
    }

    .range-slider input[type="range"]::-webkit-slider-runnable-track {
      height: 2px;
      background: transparent;
    }

    .range-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #4caf50;
      border-radius: 50%;
      cursor: pointer;
      pointer-events: auto;
      border: none;
      margin-top: -9px;
      transition: transform 0.15s, box-shadow 0.15s;
    }

    .range-slider input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.3);
      box-shadow: 0 0 0 6px rgba(76, 175, 80, 0.15);
    }

    .range-slider input[type="range"]::-moz-range-track {
      height: 2px;
      background: transparent;
    }

    .range-slider input[type="range"]::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #4caf50;
      border-radius: 50%;
      cursor: pointer;
      pointer-events: auto;
      border: none;
      transition: transform 0.15s, box-shadow 0.15s;
    }

    .range-slider input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.3);
      box-shadow: 0 0 0 6px rgba(76, 175, 80, 0.15);
    }

    .participants {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid var(--border);
    }

    .participant {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.5rem 0;
      font-size: 0.875rem;
      color: var(--text);
    }

    .participant-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #34c759;
    }

    .main {
      background: var(--bg-card);
      border-radius: 12px;
      padding: 1.5rem;
      box-shadow: 0 1px 3px var(--shadow);
      border: 1px solid var(--border);
      overflow-x: auto;
    }

    .grid-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 1rem;
      flex-wrap: wrap;
      gap: 1rem;
    }

    .mode-toggle {
      display: flex;
      background: var(--bg-secondary);
      border-radius: 8px;
      padding: 3px;
    }

    .mode-toggle button {
      padding: 0.5rem 1rem;
      border: none;
      background: transparent;
      border-radius: 6px;
      font-size: 0.875rem;
      cursor: pointer;
      color: var(--text-secondary);
      transition: all 0.2s;
    }

    .mode-toggle button.active {
      background: var(--bg-card);
      color: var(--text);
      box-shadow: 0 1px 2px var(--shadow);
    }

    .week-nav {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .nav-btn {
      width: 32px;
      height: 32px;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text);
      border-radius: 6px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      transition: all 0.2s;
    }

    .nav-btn:hover:not(:disabled) {
      background: var(--border);
    }

    .nav-btn:disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }

    .week-label {
      font-size: 0.8125rem;
      color: var(--text-secondary);
      min-width: 100px;
      text-align: center;
    }

    .legend {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: var(--text-secondary);
    }

    .legend-bar {
      width: 100px;
      height: 12px;
      border-radius: 3px;
      background: linear-gradient(to right, #1a3d1a, #4caf50);
    }

    [data-theme="dark"] .legend-bar {
      background: linear-gradient(to right, #1e3d1e, #5ea65e);
    }

    .grid-container {
      position: relative;
      user-select: none;
    }

    .grid {
      display: grid;
      gap: 1px;
      background: var(--border);
      border-radius: 8px;
      overflow: hidden;
    }

    .grid-cell {
      background: var(--bg-cell);
      min-height: 24px;
      transition: background-color 0.1s;
      cursor: pointer;
      position: relative;
    }

    .grid-cell.header {
      background: var(--bg-secondary);
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0.75rem 0.5rem;
      cursor: default;
    }

    .grid-cell.time-label {
      background: var(--bg-secondary);
      font-size: 0.6875rem;
      color: var(--text-secondary);
      display: flex;
      align-items: flex-start;
      justify-content: flex-end;
      padding: 2px 8px 0 0;
      cursor: default;
    }

    .grid-cell.time-label.faded {
      color: var(--text-secondary);
      opacity: 0.5;
      font-size: 0.625rem;
    }

    .grid-cell.available {
      background: #4caf50;
    }

    [data-theme="dark"] .grid-cell.available {
      background: #43a047;
    }

    /* Others' selections shown faintly in edit mode */
    .grid-cell.others-selected {
      background: rgba(76, 175, 80, 0.15);
    }
    .grid-cell.available.others-selected {
      background: #4caf50;
    }
    [data-theme="dark"] .grid-cell.others-selected {
      background: rgba(76, 175, 80, 0.2);
    }
    [data-theme="dark"] .grid-cell.available.others-selected {
      background: #43a047;
    }
    .others-indicator {
      position: absolute;
      bottom: 2px;
      right: 3px;
      font-size: 10px;
      opacity: 0.5;
      color: #4caf50;
    }
    .grid-cell.available .others-indicator {
      color: white;
      opacity: 0.8;
    }

    .grid-cell.available-1 { background: #1e3d1e; }
    .grid-cell.available-2 { background: #264826; }
    .grid-cell.available-3 { background: #2e542e; }
    .grid-cell.available-4 { background: #366136; }
    .grid-cell.available-5 { background: #3e6e3e; }
    .grid-cell.available-6 { background: #467c46; }
    .grid-cell.available-7 { background: #4e8a4e; }
    .grid-cell.available-8 { background: #569856; }
    .grid-cell.available-9 { background: #5ea65e; }

    [data-theme="light"] .grid-cell.available-1 { background: #e8f5e9; }
    [data-theme="light"] .grid-cell.available-2 { background: #c8e6c9; }
    [data-theme="light"] .grid-cell.available-3 { background: #a5d6a7; }
    [data-theme="light"] .grid-cell.available-4 { background: #81c784; }
    [data-theme="light"] .grid-cell.available-5 { background: #66bb6a; }
    [data-theme="light"] .grid-cell.available-6 { background: #4caf50; }
    [data-theme="light"] .grid-cell.available-7 { background: #43a047; }
    [data-theme="light"] .grid-cell.available-8 { background: #388e3c; }
    [data-theme="light"] .grid-cell.available-9 { background: #2e7d32; }

    .grid-cell.perfect-match {
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.8), 0 0 8px rgba(255,255,255,0.3);
    }

    .grid-cell .cell-count {
      font-size: 0.625rem;
      color: rgba(255,255,255,0.9);
      text-align: center;
      line-height: 24px;
      font-weight: 600;
      text-shadow: 0 1px 2px rgba(0,0,0,0.3);
    }

    .best-times {
      margin-top: 1rem;
      padding: 0.75rem 1rem;
      background: rgba(76, 175, 80, 0.15);
      border: 1px solid rgba(76, 175, 80, 0.3);
      border-radius: 8px;
      font-size: 0.8125rem;
      color: var(--text);
      display: none;
    }

    .best-times.visible {
      display: block;
    }

    .best-times strong {
      color: #4caf50;
    }

    .grid-cell:not(.header):not(.time-label):hover {
      filter: brightness(1.1);
    }

    .now-indicator {
      position: absolute;
      left: 60px;
      right: 0;
      height: 2px;
      background: #ef4444;
      pointer-events: none;
      z-index: 10;
    }

    .now-indicator::before {
      content: '';
      position: absolute;
      left: -4px;
      top: -3px;
      width: 8px;
      height: 8px;
      background: #ef4444;
      border-radius: 50%;
    }

    .date-header {
      text-align: center;
    }

    .date-header .day-name {
      font-size: 0.6875rem;
      color: var(--text-secondary);
      font-weight: 500;
    }

    .date-header .day-num {
      font-size: 1rem;
      font-weight: 600;
    }

    .instructions {
      margin-top: 1rem;
      padding: 1rem;
      background: var(--bg-secondary);
      border-radius: 8px;
      font-size: 0.8125rem;
      color: var(--text-secondary);
    }

    .btn-row {
      display: flex;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .btn {
      flex: 1;
      padding: 0.75rem;
      border: none;
      border-radius: 8px;
      font-size: 0.875rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background: #0071e3;
      color: white;
    }

    .btn-primary:hover {
      background: #0077ed;
    }

    .btn-secondary {
      background: var(--bg-secondary);
      color: var(--text);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--border);
    }

    .btn-copy {
      background: rgba(76, 175, 80, 0.15);
      color: #4caf50;
      border: 1px solid rgba(76, 175, 80, 0.3);
    }

    .btn-copy:hover {
      background: rgba(76, 175, 80, 0.25);
    }

    .btn-copy.copied {
      background: #4caf50;
      color: white;
      border-color: #4caf50;
    }

    .btn-copy.pulse {
      animation: pulse 0.6s ease-out;
    }

    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.5); }
      100% { box-shadow: 0 0 0 12px rgba(76, 175, 80, 0); }
    }

    .tooltip {
      position: absolute;
      background: var(--tooltip-bg);
      color: var(--tooltip-text);
      padding: 0.5rem 0.75rem;
      border-radius: 6px;
      font-size: 0.75rem;
      pointer-events: none;
      z-index: 100;
      opacity: 0;
      transition: opacity 0.15s;
      white-space: nowrap;
    }

    .tooltip.visible {
      opacity: 1;
    }

    @media (max-width: 768px) {
      .panels {
        grid-template-columns: 1fr;
      }

      body {
        padding: 1rem;
      }

      .grid-cell.header {
        padding: 0.5rem 0.25rem;
      }

      .date-header .day-num {
        font-size: 0.875rem;
      }
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal {
      background: var(--bg-secondary);
      border-radius: 12px;
      padding: 24px;
      max-width: 320px;
      width: 90%;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }
    .modal-title {
      font-size: 1.1rem;
      font-weight: 600;
      margin-bottom: 12px;
    }
    .modal-body {
      color: var(--text-secondary);
      margin-bottom: 20px;
      line-height: 1.5;
    }
    .modal-body strong {
      color: var(--text);
    }
    .modal-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .modal-btn {
      padding: 12px 16px;
      border: none;
      border-radius: 8px;
      font-size: 0.9rem;
      cursor: pointer;
      background: #4caf50;
      color: white;
      font-weight: 500;
    }
    .modal-btn:hover {
      background: #43a047;
    }
    .modal-btn.secondary {
      background: var(--bg-cell);
      color: var(--text);
    }
    .modal-btn.secondary:hover {
      background: var(--border);
    }

    /* Recent events */
    .recent-events {
      margin-top: 1.5rem;
      padding-top: 1.5rem;
      border-top: 1px solid var(--border);
    }

    .recent-event {
      display: block;
      padding: 0.625rem 0.75rem;
      margin-bottom: 0.5rem;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      text-decoration: none;
      color: var(--text);
      font-size: 0.875rem;
      transition: background 0.2s;
    }

    .recent-event:hover {
      background: var(--border);
    }

    .recent-event-title {
      font-weight: 500;
      margin-bottom: 0.25rem;
    }

    .recent-event-meta {
      font-size: 0.75rem;
      color: var(--text-secondary);
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <div class="logo">
          <svg viewBox="0 0 100 100" fill="none">
            <rect x="10" y="30" width="40" height="40" rx="8" fill="#4caf50" opacity="0.7"/>
            <rect x="50" y="30" width="40" height="40" rx="8" fill="#2196f3" opacity="0.7"/>
          </svg>
          <h1>Overlap</h1>
        </div>
        <p class="subtitle">Share this link to find a time that works</p>
      </div>
      <button class="theme-toggle" onclick="toggleTheme()" title="Toggle theme">
        <svg class="sun-icon" viewBox="0 0 24 24" style="display: none;">
          <circle cx="12" cy="12" r="4"/>
          <path d="M12 2v2M12 20v2M4.93 4.93l1.41 1.41M17.66 17.66l1.41 1.41M2 12h2M20 12h2M4.93 19.07l1.41-1.41M17.66 6.34l1.41-1.41"/>
        </svg>
        <svg class="moon-icon" viewBox="0 0 24 24">
          <path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/>
        </svg>
      </button>
    </header>

    <div class="panels">
      <div class="sidebar">
        <div class="form-group">
          <label>Your Name</label>
          <input type="text" id="userName" placeholder="Enter to mark availability">
        </div>

        <div class="form-group">
          <label>Hours to show <span id="timeRangeLabel" class="range-label"></span></label>
          <div class="range-slider">
            <div class="range-track"></div>
            <div class="range-highlight" id="rangeHighlight"></div>
            <input type="range" id="startTime" min="0" max="24" value="9">
            <input type="range" id="endTime" min="0" max="24" value="17">
          </div>
        </div>

        <div class="btn-row">
          <button class="btn btn-secondary" onclick="clearMyAvailability()">Clear</button>
          <button class="btn btn-copy" id="copyBtn" onclick="copyLink()">Share Link</button>
        </div>

        <div class="participants">
          <h2>Participants</h2>
          <div id="participantList">
            <p style="font-size: 0.8125rem; color: var(--text-secondary);">No one yet</p>
          </div>
        </div>

        <div class="recent-events" id="recentEventsSection" style="display: none;">
          <h2>My Recent Events</h2>
          <div id="recentEventsList"></div>
        </div>
      </div>

      <div class="main">
        <input type="text" id="eventTitle" class="event-title" placeholder="What are you scheduling?">
        <div class="grid-header">
          <div class="mode-toggle">
            <button class="active" id="editBtn" onclick="setMode('edit')">Me</button>
            <button onclick="setMode('view')">Group</button>
          </div>
          <div class="week-nav">
            <button class="nav-btn" id="prevWeek" onclick="prevWeek()" disabled>◀</button>
            <span class="week-label" id="weekLabel"></span>
            <button class="nav-btn" id="nextWeek" onclick="nextWeek()">▶</button>
          </div>
          <div class="legend">
            <span>0</span>
            <div class="legend-bar"></div>
            <span>All ✓</span>
          </div>
        </div>

        <div class="grid-container">
          <div class="grid" id="grid"></div>
          <div class="tooltip" id="tooltip"></div>
          <div class="now-indicator" id="nowIndicator" style="display: none;"></div>
        </div>

        <div class="best-times" id="bestTimes"></div>

        <div class="instructions">
          <span id="timezoneDisplay"></span>
          Click and drag to mark when you're free. Enter your name to save.
        </div>
      </div>
    </div>
  </div>

  <!-- Name collision modal -->
  <div id="nameModal" class="modal-overlay" style="display: none;">
    <div class="modal">
      <div class="modal-title">Is this you?</div>
      <div class="modal-body">
        <strong id="modalName"></strong> has already added their availability.
      </div>
      <div class="modal-actions">
        <button class="modal-btn" id="modalYes">Yes, that's me</button>
        <button class="modal-btn secondary" id="modalNo">No, I'm someone else</button>
      </div>
    </div>
  </div>

  <script>
    // Gun.js setup - connect to same-origin relay
    const gun = Gun({
      peers: [location.origin + '/gun'],
      localStorage: false
    });

    // Get or create event ID from URL
    function getEventId() {
      const params = new URLSearchParams(location.search);
      let eventId = params.get('event');

      if (!eventId) {
        // Generate short random ID
        eventId = Math.random().toString(36).substring(2, 10);
        history.replaceState(null, '', '?event=' + eventId);
      }
      return eventId;
    }

    const eventId = getEventId();
    const eventRef = gun.get('overlap-events').get(eventId);

    // Theme
    function initTheme() {
      const saved = localStorage.getItem('theme');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
      const theme = saved || (prefersDark ? 'dark' : 'light');
      setTheme(theme);

      // Listen for system theme changes
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
        if (!localStorage.getItem('theme')) {
          setTheme(e.matches ? 'dark' : 'light');
        }
      });
    }

    function setTheme(theme) {
      document.documentElement.setAttribute('data-theme', theme);
      localStorage.setItem('theme', theme);
      updateThemeIcon(theme);
    }

    function toggleTheme() {
      const current = document.documentElement.getAttribute('data-theme');
      setTheme(current === 'dark' ? 'light' : 'dark');
    }

    function updateThemeIcon(theme) {
      document.querySelector('.sun-icon').style.display = theme === 'dark' ? 'block' : 'none';
      document.querySelector('.moon-icon').style.display = theme === 'dark' ? 'none' : 'block';
    }

    // State
    let mode = 'edit';
    let isMouseDown = false;
    let isAdding = true;
    let startHour = 9;
    let endHour = 17;
    let days = [];
    let myAvailability = new Set();
    let allParticipants = {};
    let eventTimezone = null;
    let lastCell = null;
    let weekOffset = 0;
    let myCurrentName = null;
    let confirmedAsMe = new Set(); // Names user confirmed as theirs
    let pendingNameCheck = null; // Name waiting for confirmation
    let saveTimeout = null;
    let userManuallySwitchedMode = false;
    let initialModeSet = false;

    // Recent events storage
    const RECENT_EVENTS_KEY = 'overlap-recent-events';
    const MAX_RECENT_EVENTS = 5;

    function getRecentEvents() {
      try {
        return JSON.parse(localStorage.getItem(RECENT_EVENTS_KEY)) || [];
      } catch {
        return [];
      }
    }

    function saveToRecentEvents(id, title, name) {
      const events = getRecentEvents().filter(e => e.id !== id);
      events.unshift({ id, title: title || 'Untitled event', name, updated: Date.now() });
      localStorage.setItem(RECENT_EVENTS_KEY, JSON.stringify(events.slice(0, MAX_RECENT_EVENTS)));
      loadRecentEvents();
    }

    function loadRecentEvents() {
      const section = document.getElementById('recentEventsSection');
      const list = document.getElementById('recentEventsList');
      const events = getRecentEvents().filter(e => e.id !== eventId);

      if (events.length === 0) {
        section.style.display = 'none';
        return;
      }

      section.style.display = 'block';
      list.innerHTML = '';

      events.forEach(event => {
        const link = document.createElement('a');
        link.className = 'recent-event';
        link.href = `?event=${event.id}`;

        const title = document.createElement('div');
        title.className = 'recent-event-title';
        title.textContent = event.title;
        link.appendChild(title);

        const meta = document.createElement('div');
        meta.className = 'recent-event-meta';
        meta.textContent = `as ${event.name}`;
        link.appendChild(meta);

        list.appendChild(link);
      });
    }

    // Timezone
    function getLocalTimezone() {
      return Intl.DateTimeFormat().resolvedOptions().timeZone;
    }

    function formatTimezone(tz) {
      try {
        const name = tz.replace(/_/g, ' ');
        const offset = new Date().toLocaleString('en-US', { timeZone: tz, timeZoneName: 'shortOffset' }).split(' ').pop();
        return `${name} (${offset})`;
      } catch {
        return tz;
      }
    }

    function updateTimezoneDisplay() {
      const display = document.getElementById('timezoneDisplay');
      const localTz = getLocalTimezone();

      if (eventTimezone && eventTimezone !== localTz) {
        display.innerHTML = `<strong>Times shown in ${formatTimezone(eventTimezone)}</strong> · Your timezone: ${formatTimezone(localTz)}<br><br>`;
      } else {
        display.innerHTML = `Times shown in ${formatTimezone(localTz)}<br><br>`;
      }
    }

    // Generate 7 days starting from offset
    function generateDays() {
      const today = new Date();
      days = [];
      for (let i = 0; i < 7; i++) {
        const date = new Date(today);
        date.setDate(today.getDate() + weekOffset * 7 + i);
        days.push(date);
      }
    }

    function prevWeek() {
      if (weekOffset === 0) return;
      weekOffset--;
      generateDays();
      renderGrid();
      updateNowIndicator();
      updateWeekNav();
    }

    function nextWeek() {
      weekOffset++;
      generateDays();
      renderGrid();
      updateNowIndicator();
      updateWeekNav();
    }

    function updateWeekNav() {
      document.getElementById('prevWeek').disabled = weekOffset === 0;

      const startDate = days[0];
      const endDate = days[days.length - 1];
      const opts = { month: 'short', day: 'numeric' };
      const start = startDate.toLocaleDateString('en-US', opts);
      const end = endDate.toLocaleDateString('en-US', opts);
      document.getElementById('weekLabel').textContent = `${start} – ${end}`;
    }

    // Time range slider
    function populateTimeSelectors() {
      const startInput = document.getElementById('startTime');
      const endInput = document.getElementById('endTime');

      startInput.value = startHour;
      endInput.value = endHour;

      function updateRange() {
        const start = parseInt(startInput.value);
        const end = parseInt(endInput.value);

        // Prevent crossing
        if (start >= end) {
          if (this === startInput) {
            startInput.value = end - 1;
          } else {
            endInput.value = start + 1;
          }
        }

        startHour = parseInt(startInput.value);
        endHour = parseInt(endInput.value);

        updateTimeRangeLabel();
        updateRangeHighlight();
        renderGrid();
        updateNowIndicator();
      }

      startInput.addEventListener('input', updateRange);
      endInput.addEventListener('input', updateRange);

      updateTimeRangeLabel();
      updateRangeHighlight();

      // Update on resize since highlight uses pixel positions
      window.addEventListener('resize', updateRangeHighlight);
    }

    function updateTimeRangeLabel() {
      const label = document.getElementById('timeRangeLabel');
      label.textContent = `${formatHour(startHour)} – ${formatHour(endHour)}`;
    }

    function updateRangeHighlight() {
      const startInput = document.getElementById('startTime');
      const endInput = document.getElementById('endTime');
      const highlight = document.getElementById('rangeHighlight');

      // Use input's client width for accurate measurement
      const width = startInput.clientWidth;
      const start = parseInt(startInput.value);
      const end = parseInt(endInput.value);

      const startRatio = start / 24;
      const endRatio = end / 24;

      // Browser positions thumb so its center moves from 6px to (width - 6px)
      // Add small inset to ensure highlight stays within thumb bounds
      const thumbHalf = 7;
      const trackRange = width - thumbHalf * 2;

      const startPos = thumbHalf + startRatio * trackRange;
      const endPos = thumbHalf + endRatio * trackRange;

      highlight.style.left = startPos + 'px';
      highlight.style.width = (endPos - startPos) + 'px';
    }

    function formatHour(h) {
      const period = h < 12 ? 'AM' : 'PM';
      const hour = h === 0 ? 12 : h > 12 ? h - 12 : h;
      return hour + ' ' + period;
    }

    function formatDayName(date) {
      return date.toLocaleDateString('en-US', { weekday: 'short' });
    }

    function formatDayNum(date) {
      return date.getDate();
    }

    function getCellId(dayIndex, hour, quarter) {
      const date = days[dayIndex];
      const dateStr = date.toISOString().split('T')[0]; // YYYY-MM-DD
      return `${dateStr}-${hour}-${quarter}`;
    }

    function renderGrid() {
      const grid = document.getElementById('grid');
      const numSlots = (endHour - startHour) * 4;

      if (numSlots <= 0) return;

      grid.style.gridTemplateColumns = `60px repeat(${days.length}, 1fr)`;
      grid.innerHTML = '';

      // Header row
      const cornerCell = document.createElement('div');
      cornerCell.className = 'grid-cell header';
      grid.appendChild(cornerCell);

      days.forEach(date => {
        const headerCell = document.createElement('div');
        headerCell.className = 'grid-cell header';
        headerCell.innerHTML = `
          <div class="date-header">
            <div class="day-name">${formatDayName(date)}</div>
            <div class="day-num">${formatDayNum(date)}</div>
          </div>
        `;
        grid.appendChild(headerCell);
      });

      // Time slots
      for (let h = startHour; h < endHour; h++) {
        for (let q = 0; q < 4; q++) {
          // Time label
          const timeCell = document.createElement('div');
          timeCell.className = 'grid-cell time-label';
          if (q === 0) {
            timeCell.textContent = formatHour(h);
          } else {
            timeCell.textContent = ':' + (q * 15);
            timeCell.classList.add('faded');
          }
          grid.appendChild(timeCell);

          // Day cells
          days.forEach((date, dayIndex) => {
            const cell = document.createElement('div');
            const cellId = getCellId(dayIndex, h, q);
            cell.className = 'grid-cell';
            cell.dataset.cellId = cellId;
            cell.dataset.day = dayIndex;
            cell.dataset.hour = h;
            cell.dataset.quarter = q;

            cell.addEventListener('mousedown', onCellMouseDown);
            cell.addEventListener('mouseenter', onCellMouseEnter);
            cell.addEventListener('touchstart', onCellTouchStart, { passive: false });
            cell.addEventListener('touchmove', onCellTouchMove, { passive: false });

            grid.appendChild(cell);
          });
        }
      }

      updateGridDisplay();
    }

    function onCellMouseDown(e) {
      if (mode !== 'edit') return;
      isMouseDown = true;
      const cell = e.target;
      const cellId = cell.dataset.cellId;
      isAdding = !myAvailability.has(cellId);
      lastCell = { day: parseInt(cell.dataset.day), hour: parseInt(cell.dataset.hour), quarter: parseInt(cell.dataset.quarter) };
      toggleCell(cellId);
    }

    function onCellMouseEnter(e) {
      if (!isMouseDown || mode !== 'edit') return;
      const cell = e.target;
      const currentCell = { day: parseInt(cell.dataset.day), hour: parseInt(cell.dataset.hour), quarter: parseInt(cell.dataset.quarter) };

      if (lastCell) {
        fillCellsBetween(lastCell, currentCell);
      }

      lastCell = currentCell;
      toggleCell(cell.dataset.cellId);
    }

    function fillCellsBetween(from, to) {
      const minDay = Math.min(from.day, to.day);
      const maxDay = Math.max(from.day, to.day);
      const fromSlot = from.hour * 4 + from.quarter;
      const toSlot = to.hour * 4 + to.quarter;
      const minSlot = Math.min(fromSlot, toSlot);
      const maxSlot = Math.max(fromSlot, toSlot);

      // Fill rectangle between from and to
      for (let day = minDay; day <= maxDay; day++) {
        for (let slot = minSlot; slot <= maxSlot; slot++) {
          const hour = Math.floor(slot / 4);
          const quarter = slot % 4;
          const cellId = getCellId(day, hour, quarter);
          isAdding ? myAvailability.add(cellId) : myAvailability.delete(cellId);
        }
      }
    }

    function onCellTouchStart(e) {
      if (mode !== 'edit') return;
      e.preventDefault();
      isMouseDown = true;
      const touch = e.touches[0];
      const cell = document.elementFromPoint(touch.clientX, touch.clientY);
      if (cell && cell.dataset.cellId) {
        isAdding = !myAvailability.has(cell.dataset.cellId);
        lastCell = { day: parseInt(cell.dataset.day), hour: parseInt(cell.dataset.hour), quarter: parseInt(cell.dataset.quarter) };
        toggleCell(cell.dataset.cellId);
      }
    }

    function onCellTouchMove(e) {
      if (!isMouseDown || mode !== 'edit') return;
      e.preventDefault();
      const touch = e.touches[0];
      const cell = document.elementFromPoint(touch.clientX, touch.clientY);
      if (cell && cell.dataset.cellId) {
        const currentCell = { day: parseInt(cell.dataset.day), hour: parseInt(cell.dataset.hour), quarter: parseInt(cell.dataset.quarter) };
        if (lastCell) {
          fillCellsBetween(lastCell, currentCell);
        }
        lastCell = currentCell;
        toggleCell(cell.dataset.cellId);
      }
    }

    function toggleCell(cellId) {
      if (!cellId) return;
      isAdding ? myAvailability.add(cellId) : myAvailability.delete(cellId);
      updateGridDisplay();
      autoSave();
    }

    function autoSave() {
      const name = document.getElementById('userName').value.trim();
      if (!name) return;

      // Check for name collision - someone else might have this name
      if (allParticipants[name] && allParticipants[name].size > 0 &&
          name !== myCurrentName && !confirmedAsMe.has(name)) {
        showNameModal(name);
        return;
      }

      proceedWithSave(name);
    }

    function proceedWithSave(name) {
      // Set timezone on first save
      if (!eventTimezone) {
        eventTimezone = getLocalTimezone();
        eventRef.get('timezone').put(eventTimezone);
        updateTimezoneDisplay();
      }

      // Remove old name from Gun if changed
      if (myCurrentName && myCurrentName !== name) {
        eventRef.get('participants').get(myCurrentName).put(null);
        delete allParticipants[myCurrentName];
      }
      myCurrentName = name;

      // If this participant already exists and confirmed as me, load their selections
      if (allParticipants[name] && allParticipants[name].size > 0 && myAvailability.size === 0) {
        myAvailability = new Set(allParticipants[name]);
        updateGridDisplay();
      } else {
        allParticipants[name] = new Set(myAvailability);
      }
      updateParticipantList();

      // Debounce saves to Gun
      clearTimeout(saveTimeout);
      saveTimeout = setTimeout(() => {
        eventRef.get('participants').get(name).put({
          slots: Array.from(myAvailability).join(','),
          tz: getLocalTimezone(),
          updated: Date.now()
        });

        // Save to recent events only if there's actual availability data
        if (myAvailability.size > 0) {
          const title = document.getElementById('eventTitle').value.trim();
          saveToRecentEvents(eventId, title, name);
        }
      }, 300);
    }

    function showNameModal(name) {
      pendingNameCheck = name;
      document.getElementById('modalName').textContent = name;
      document.getElementById('nameModal').style.display = 'flex';
    }

    function hideNameModal() {
      document.getElementById('nameModal').style.display = 'none';
      pendingNameCheck = null;
    }

    document.getElementById('modalYes').addEventListener('click', () => {
      if (pendingNameCheck) {
        confirmedAsMe.add(pendingNameCheck);
        proceedWithSave(pendingNameCheck);
      }
      hideNameModal();
    });

    document.getElementById('modalNo').addEventListener('click', () => {
      hideNameModal();
      const input = document.getElementById('userName');
      const currentName = input.value.trim();
      // Suggest adding last initial
      input.value = currentName + ' ';
      input.focus();
      input.setSelectionRange(input.value.length, input.value.length);
    });

    document.addEventListener('mouseup', () => {
      isMouseDown = false;
      lastCell = null;
    });

    document.addEventListener('touchend', () => {
      isMouseDown = false;
      lastCell = null;
    });

    function updateGridDisplay() {
      const cells = document.querySelectorAll('.grid-cell[data-cell-id]');
      const tooltip = document.getElementById('tooltip');
      const bestTimesEl = document.getElementById('bestTimes');

      if (mode === 'edit') {
        const otherParticipants = Object.entries(allParticipants).filter(([name]) => name !== myCurrentName);
        const otherCount = otherParticipants.length;

        cells.forEach(cell => {
          const cellId = cell.dataset.cellId;
          const mine = myAvailability.has(cellId);
          const othersWithSlot = otherParticipants.filter(([, slots]) => slots.has(cellId)).length;

          cell.className = 'grid-cell';
          if (mine) cell.classList.add('available');
          if (othersWithSlot > 0) cell.classList.add('others-selected');
          cell.innerHTML = '';

          // Show faint count of others
          if (othersWithSlot > 0 && otherCount > 0) {
            const indicator = document.createElement('div');
            indicator.className = 'others-indicator';
            indicator.textContent = othersWithSlot;
            cell.appendChild(indicator);
          }
        });
        bestTimesEl.classList.remove('visible');
      } else {
        // View mode - show aggregate
        const participantCount = Object.keys(allParticipants).length;
        const perfectMatches = [];

        cells.forEach(cell => {
          const cellId = cell.dataset.cellId;
          const count = Object.values(allParticipants).filter(slots => slots.has(cellId)).length;

          cell.className = 'grid-cell';
          cell.innerHTML = '';

          if (count > 0 && participantCount > 0) {
            const level = Math.ceil((count / participantCount) * 9);
            cell.classList.add(`available-${level}`);

            // Show count
            const countEl = document.createElement('div');
            countEl.className = 'cell-count';
            countEl.textContent = `${count}/${participantCount}`;
            cell.appendChild(countEl);

            // Highlight perfect match
            if (count === participantCount) {
              cell.classList.add('perfect-match');
              perfectMatches.push(cellId);
            }
          }

          // Add hover for tooltip
          cell.onmouseenter = (e) => {
            if (mode !== 'view') return;
            const names = Object.entries(allParticipants)
              .filter(([, slots]) => slots.has(cellId))
              .map(([name]) => name);
            if (names.length > 0) {
              tooltip.textContent = names.join(', ');
              tooltip.classList.add('visible');
              const rect = cell.getBoundingClientRect();
              const containerRect = cell.closest('.grid-container').getBoundingClientRect();
              tooltip.style.left = Math.max(0, rect.left - containerRect.left + rect.width / 2 - tooltip.offsetWidth / 2) + 'px';
              tooltip.style.top = (rect.top - containerRect.top - tooltip.offsetHeight - 8) + 'px';
            }
          };
          cell.onmouseleave = () => {
            tooltip.classList.remove('visible');
          };
        });

        // Show best times summary
        if (participantCount > 1 && perfectMatches.length > 0) {
          const summary = formatBestTimes(perfectMatches);
          bestTimesEl.innerHTML = `<strong>Everyone's free:</strong> ${summary}`;
          bestTimesEl.classList.add('visible');
        } else {
          bestTimesEl.classList.remove('visible');
        }
      }
    }

    function formatBestTimes(cellIds) {
      // Group consecutive slots into ranges
      const slots = cellIds.map(id => {
        const parts = id.split('-');
        const dateStr = parts.slice(0, 3).join('-');
        const hour = parseInt(parts[3]);
        const quarter = parseInt(parts[4]);
        return { dateStr, hour, quarter, minutes: hour * 60 + quarter * 15 };
      }).sort((a, b) => a.dateStr.localeCompare(b.dateStr) || a.minutes - b.minutes);

      const ranges = [];
      let currentRange = null;

      slots.forEach(slot => {
        if (!currentRange || currentRange.dateStr !== slot.dateStr || slot.minutes !== currentRange.endMinutes + 15) {
          if (currentRange) ranges.push(currentRange);
          currentRange = { dateStr: slot.dateStr, startMinutes: slot.minutes, endMinutes: slot.minutes };
        } else {
          currentRange.endMinutes = slot.minutes;
        }
      });
      if (currentRange) ranges.push(currentRange);

      // Format ranges (limit to 3)
      return ranges.slice(0, 3).map(r => {
        const date = new Date(r.dateStr);
        const dayName = date.toLocaleDateString('en-US', { weekday: 'short' });
        const startTime = formatTime(r.startMinutes);
        const endTime = formatTime(r.endMinutes + 15);
        return `${dayName} ${startTime}–${endTime}`;
      }).join(', ') + (ranges.length > 3 ? ` +${ranges.length - 3} more` : '');
    }

    function formatTime(minutes) {
      const h = Math.floor(minutes / 60);
      const m = minutes % 60;
      const period = h < 12 ? 'am' : 'pm';
      const hour = h === 0 ? 12 : h > 12 ? h - 12 : h;
      if (m === 0) return hour + period;
      return hour + ':' + m.toString().padStart(2, '0') + period;
    }

    function setMode(newMode, manual = true) {
      mode = newMode;
      if (manual) userManuallySwitchedMode = true;
      const buttons = document.querySelectorAll('.mode-toggle button');
      buttons[0].classList.toggle('active', mode === 'edit');
      buttons[1].classList.toggle('active', mode === 'view');
      updateGridDisplay();
    }

    function clearMyAvailability() {
      myAvailability.clear();
      updateGridDisplay();
      autoSave();
    }

    function updateParticipantList() {
      const list = document.getElementById('participantList');
      const names = Object.keys(allParticipants);

      if (names.length === 0) {
        list.innerHTML = '<p style="font-size: 0.8125rem; color: var(--text-secondary);">No one yet</p>';
        return;
      }

      list.innerHTML = '';
      names.forEach(name => {
        const div = document.createElement('div');
        div.className = 'participant';
        div.innerHTML = `<span class="participant-dot"></span>${name}`;
        list.appendChild(div);
      });
    }

    // Subscribe to Gun.js for real-time updates
    function subscribeToEvent() {
      const titleInput = document.getElementById('eventTitle');

      // Get event title
      eventRef.get('title').on((title) => {
        if (title && document.activeElement !== titleInput) {
          titleInput.value = title;
          document.title = `${title} - Overlap`;
        }
      });

      // Get event timezone
      eventRef.get('timezone').on((tz) => {
        if (tz && !eventTimezone) {
          eventTimezone = tz;
          updateTimezoneDisplay();
        }
      });

      // Subscribe to all participants
      eventRef.get('participants').map().on((data, name) => {
        if (!name) return;

        // Handle deleted participants
        if (!data || data === null) {
          delete allParticipants[name];
          updateParticipantList();
          updateGridDisplay();
          return;
        }

        // Skip if this is our own data and we're currently editing
        if (name === myCurrentName) return;

        // Parse slots
        const slots = data.slots ? data.slots.split(',').filter(Boolean) : [];
        allParticipants[name] = new Set(slots);

        // On first participant data, switch to Group view if there are participants
        if (!initialModeSet && Object.keys(allParticipants).length > 0) {
          initialModeSet = true;
          setMode('view', false);
        }

        updateParticipantList();
        updateGridDisplay();
      });

      // Title input handler
      let titleTimeout = null;
      titleInput.addEventListener('input', () => {
        clearTimeout(titleTimeout);
        titleTimeout = setTimeout(() => {
          const title = titleInput.value.trim();
          if (title) {
            eventRef.get('title').put(title);
            document.title = `${title} - Overlap`;
          } else {
            document.title = 'Overlap - Find a time that works for everyone';
          }

          // Update recent events if we have saved data
          if (myCurrentName && myAvailability.size > 0) {
            saveToRecentEvents(eventId, title, myCurrentName);
          }
        }, 300);
      });
    }

    function copyLink() {
      const btn = document.getElementById('copyBtn');

      navigator.clipboard.writeText(window.location.href).then(() => {
        btn.textContent = 'Copied!';
        btn.classList.add('copied');
        setTimeout(() => {
          btn.textContent = 'Share Link';
          btn.classList.remove('copied');
        }, 2000);
      });
    }

    // Current time indicator
    function updateNowIndicator() {
      const indicator = document.getElementById('nowIndicator');
      const grid = document.getElementById('grid');

      // Only show on current week (weekOffset 0)
      if (weekOffset !== 0) {
        indicator.style.display = 'none';
        return;
      }

      const now = new Date();
      const currentHour = now.getHours();
      const currentMinute = now.getMinutes();

      // Check if current time is in visible range
      if (currentHour < startHour || currentHour >= endHour) {
        indicator.style.display = 'none';
        return;
      }

      // Calculate position
      const headerHeight = grid.querySelector('.grid-cell.header')?.offsetHeight || 0;
      const cellHeight = 24; // min-height of cells
      const gap = 1; // grid gap

      const slotsFromStart = (currentHour - startHour) * 4 + Math.floor(currentMinute / 15);
      const minuteOffset = (currentMinute % 15) / 15 * (cellHeight + gap);
      const topPosition = headerHeight + gap + slotsFromStart * (cellHeight + gap) + minuteOffset;

      indicator.style.display = 'block';
      indicator.style.top = topPosition + 'px';
    }

    // Auto-focus name input when typing (but not if in another input)
    document.addEventListener('keydown', (e) => {
      if (document.activeElement.tagName === 'INPUT') return;
      if (e.ctrlKey || e.metaKey || e.altKey) return;
      if (e.key.length !== 1) return;
      document.getElementById('userName').focus();
    });

    // Initialize
    initTheme();
    generateDays();
    populateTimeSelectors();
    subscribeToEvent();
    renderGrid();
    updateParticipantList();
    updateTimezoneDisplay();
    updateNowIndicator();
    updateWeekNav();
    loadRecentEvents();
    setInterval(updateNowIndicator, 60000);

    // Auto-focus name input on load
    const nameInput = document.getElementById('userName');
    nameInput.focus();

    // Update participant name in real-time
    nameInput.addEventListener('input', () => {
      // Auto-switch to edit mode when user starts typing name
      if (!userManuallySwitchedMode && mode !== 'edit') {
        setMode('edit', false);
      }
      autoSave();
      updateEditButtonLabel();
    });

    function updateEditButtonLabel() {
      const name = document.getElementById('userName').value.trim();
      document.getElementById('editBtn').textContent = name || 'Me';
    }
  </script>
</body>
</html>
